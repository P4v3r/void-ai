import os
import json
import time
import hashlib
import ipaddress
import hmac
import secrets
import sqlite3
from typing import List, Literal, Optional, Dict, AsyncGenerator

import httpx
from fastapi import FastAPI, Request, HTTPException, Header
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse, JSONResponse
from pydantic import BaseModel
from redis.asyncio import Redis

from dotenv import load_dotenv
load_dotenv()

app = FastAPI()

OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "dolphin-mistral")

REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379/0")

FREE_LIMIT = int(os.getenv("FREE_LIMIT", "2"))
FREE_TTL_SECONDS = int(os.getenv("FREE_TTL_SECONDS", str(24 * 60 * 60)))

RL_WINDOW_SECONDS = int(os.getenv("RL_WINDOW_SECONDS", "60"))
RL_MAX_REQUESTS = int(os.getenv("RL_MAX_REQUESTS", "30"))
# rate limit per IP-bucket (anti bypass)
RL_MAX_REQUESTS_IP = int(os.getenv("RL_MAX_REQUESTS_IP", "10"))
# rate limit per client-id (per impedire che 1 tab “bruci” tutto l’IP)
RL_MAX_REQUESTS_CID = int(os.getenv("RL_MAX_REQUESTS_CID", "20"))

DEV_RESET_ENABLED = os.getenv("DEV_RESET_ENABLED", "0") == "1"

BTCPAY_URL = os.getenv("BTCPAY_URL", "https://testnet.demo.btcpayserver.org")
BTCPAY_STORE_ID = os.getenv("BTCPAY_STORE_ID", "")
BTCPAY_API_KEY = os.getenv("BTCPAY_API_KEY", "")

DB_PATH = os.getenv("DB_PATH", "void.db")
BTCPAY_WEBHOOK_SECRET = os.getenv("BTCPAY_WEBHOOK_SECRET", "")

redis: Optional[Redis] = None

app.add_middleware(
  CORSMiddleware,
  allow_origin_regex=r"http://localhost:3000",
  allow_credentials=False,
  allow_methods=["*"],
  allow_headers=["*"],
  expose_headers=[
    "X-Free-Left",
    "X-Pro-Left",
    "X-RateLimit-Limit",
    "X-RateLimit-Remaining",
    "Retry-After",
  ],
)

class ChatMsg(BaseModel):
  role: Literal["system", "user", "assistant"]
  content: str

class ChatIn(BaseModel):
  messages: Optional[List[ChatMsg]] = None
  message: Optional[str] = None

class ProInvoiceIn(BaseModel):
  amount: str = "1"      # prezzo (stringa, come negli esempi BTCPay)
  currency: str = "USD"  # o "EUR"
  credits: int = 1000    # quanti crediti pro vuoi dare dopo pagamento

class ClaimIn(BaseModel):
  invoiceId: str

FREE_LUA = """
local v = redis.call('GET', KEYS[1])
if not v then
  redis.call('SET', KEYS[1], ARGV[1], 'EX', ARGV[2])
  v = ARGV[1]
end
local n = tonumber(v)
if n <= 0 then
  return -1
end
n = redis.call('DECR', KEYS[1])
return n
"""

RL_LUA = """
local current = redis.call('INCR', KEYS[1])
if current == 1 then
  redis.call('EXPIRE', KEYS[1], ARGV[2])
end
local ttl = redis.call('TTL', KEYS[1])
local maxv = tonumber(ARGV[1])
if current > maxv then
  return {-1, ttl}
end
return {maxv - current, ttl}
"""

def _db():
  conn = sqlite3.connect(DB_PATH)
  conn.execute("""
    CREATE TABLE IF NOT EXISTS pro_tokens (
      token_hash TEXT PRIMARY KEY,
      credits_left INTEGER NOT NULL,
      created_at INTEGER NOT NULL
    )
  """)
  conn.execute("""
    CREATE TABLE IF NOT EXISTS paid_invoices (
      invoice_id TEXT PRIMARY KEY,
      created_at INTEGER NOT NULL
    )
  """)
  conn.execute("""
  CREATE TABLE IF NOT EXISTS pending_invoices (
    invoice_id TEXT PRIMARY KEY,
    credits INTEGER NOT NULL,
    created_at INTEGER NOT NULL
  )
  """)
  conn.execute("""
    CREATE TABLE IF NOT EXISTS invoice_claims (
      invoice_id TEXT PRIMARY KEY,
      token_plain TEXT,
      token_hash TEXT NOT NULL,
      credits INTEGER NOT NULL,
      claimed INTEGER NOT NULL DEFAULT 0,
      created_at INTEGER NOT NULL
    )
  """)
  conn.commit()
  return conn

def _verify_btcpay_sig(raw_body: bytes, btcpay_sig: str, secret: str) -> bool:
  # BTCPay-Sig format: "sha256=<hexdigest>" [web:263]
  if not btcpay_sig or not btcpay_sig.startswith("sha256="):
    return False
  their = btcpay_sig.split("=", 1)[1].strip()

  mac = hmac.new(secret.encode("utf-8"), raw_body, hashlib.sha256).hexdigest()
  return hmac.compare_digest(mac, their)

def _new_pro_token() -> str:
  # token casuale copiabile dall’utente
  return "void_" + secrets.token_urlsafe(32)

def _hash_token(token: str) -> str:
  return hashlib.sha256(token.encode("utf-8")).hexdigest()


def _sha256(s: str) -> str:
  return hashlib.sha256(s.encode("utf-8")).hexdigest()

def _get_client_key(request: Request) -> str:
  cid = request.headers.get("x-void-client-id")
  if cid and len(cid) >= 8:
    return "cid:" + _sha256(cid)

  ip = request.client.host if request.client else "unknown"
  ua = request.headers.get("user-agent", "unknown")
  return "fpr:" + _sha256(ip + "|" + ua)

def _ip_bucket(request: Request) -> str:
  ip = (
    request.headers.get("cf-connecting-ip")
    or (request.headers.get("x-forwarded-for", "").split(",")[0].strip() or None)
    or (request.client.host if request.client else "unknown")
  )

# TODO VPS (dietro Nginx/Caddy):
# uvicorn main:app --host 0.0.0.0 --port 8000 --proxy-headers --forwarded-allow-ips="127.0.0.1"

# VPS MODE (dietro reverse proxy):
# def _client_ip(request: Request) -> str:
#   xff = request.headers.get("x-forwarded-for", "")
#   if xff:
#     return xff.split(",")[0].strip()
#   return request.client.host if request.client else "unknown"

  try:
    addr = ipaddress.ip_address(ip)
    if addr.version == 4:
      net = ipaddress.ip_network(f"{ip}/24", strict=False)
    else:
      net = ipaddress.ip_network(f"{ip}/64", strict=False)
    return "ip:" + _sha256(str(net))
  except Exception:
    return "ip:" + _sha256(ip)

def _build_msgs(body: ChatIn) -> List[dict]:
  if body.messages and len(body.messages) > 0:
    return [m.model_dump() for m in body.messages]
  return [{"role": "user", "content": body.message or ""}]

async def _enforce_limits(request: Request) -> Dict[str, str]:
  if redis is None:
    raise HTTPException(status_code=503, detail="Redis not configured")

  ckey = _get_client_key(request)
  ipkey = _ip_bucket(request)

  # 1) Rate limit fixed-window (DOPPIO: IP + client-id)
  window_id = int(time.time() // RL_WINDOW_SECONDS)

  rl_key_ip = f"rlip:{ipkey}:{window_id}"
  rl_key_cid = f"rlcid:{ckey}:{window_id}"

  rem_ip, ttl_ip = await redis.eval(RL_LUA, 1, rl_key_ip, RL_MAX_REQUESTS, RL_WINDOW_SECONDS)
  rem_cid, ttl_cid = await redis.eval(RL_LUA, 1, rl_key_cid, RL_MAX_REQUESTS, RL_WINDOW_SECONDS)

  rem_ip = int(rem_ip)
  rem_cid = int(rem_cid)
  ttl_ip = int(ttl_ip) if ttl_ip is not None else RL_WINDOW_SECONDS
  ttl_cid = int(ttl_cid) if ttl_cid is not None else RL_WINDOW_SECONDS

  headers: Dict[str, str] = {
    "X-RateLimit-Limit": str(RL_MAX_REQUESTS),
    "X-RateLimit-Remaining": str(min(max(rem_ip, 0), max(rem_cid, 0))),
  }

  if rem_ip < 0 or rem_cid < 0:
    headers["Retry-After"] = str(max(min(ttl_ip, ttl_cid), 1))
    raise HTTPException(status_code=429, detail="Rate limit exceeded", headers=headers)

  # 1.5) Pro credits (se presenti, NON consumare free)
  pro = (request.headers.get("x-void-pro-token") or "").strip()
  if pro:
    th = _hash_token(pro)
    conn = _db()
    try:
      cur = conn.execute("SELECT credits_left FROM pro_tokens WHERE token_hash = ?", (th,))
      row = cur.fetchone()

      if not row:
        # token inesistente => meglio errore chiaro
        raise HTTPException(status_code=401, detail="Invalid pro token", headers=headers)

      if int(row[0]) <= 0:
        headers["X-Pro-Left"] = "0"
        raise HTTPException(status_code=402, detail="Pro credits exhausted", headers=headers)

      # scala 1 credito pro
      conn.execute(
        "UPDATE pro_tokens SET credits_left = credits_left - 1 WHERE token_hash = ? AND credits_left > 0",
        (th,),
      )
      conn.commit()

      cur = conn.execute("SELECT credits_left FROM pro_tokens WHERE token_hash = ?", (th,))
      left = int(cur.fetchone()[0])
      headers["X-Pro-Left"] = str(left)

      return headers
    finally:
      conn.close()

  # 2) Free credits (per IP-bucket)
  free_key = f"free:{ipkey}"
  new_left = await redis.eval(FREE_LUA, 1, free_key, FREE_LIMIT, FREE_TTL_SECONDS)
  new_left = int(new_left)

  headers["X-Free-Left"] = str(max(new_left, 0))

  if new_left < 0:
    raise HTTPException(status_code=402, detail="Free limit reached", headers=headers)

  return headers

@app.on_event("startup")
async def _startup():
  global redis
  redis = Redis.from_url(REDIS_URL, decode_responses=True)

@app.on_event("shutdown")
async def _shutdown():
  global redis
  if redis is not None:
    await redis.close()
    redis = None

@app.exception_handler(HTTPException)
async def _http_exc_handler(request: Request, exc: HTTPException):
  resp = JSONResponse(status_code=exc.status_code, content={"detail": exc.detail})
  if exc.headers:
    for k, v in exc.headers.items():
      resp.headers[k] = v
  return resp

@app.post("/pro/create-invoice")
async def pro_create_invoice(body: ProInvoiceIn):
  if not BTCPAY_STORE_ID or not BTCPAY_API_KEY:
    raise HTTPException(status_code=500, detail="BTCPay not configured")

  url = f"{BTCPAY_URL}/api/v1/stores/{BTCPAY_STORE_ID}/invoices"
  payload = {
    "amount": body.amount,
    "currency": body.currency,
    # tieni metadata MINIMA per privacy (non mettere chat o dati personali)
    "metadata": {
      "orderId": f"voidpro-{int(time.time())}",
      "credits": body.credits,
    },
  }

  async with httpx.AsyncClient(timeout=30) as client:
    r = await client.post(
      url,
      headers={
        "Content-Type": "application/json",
        "Authorization": f"token {BTCPAY_API_KEY}",
      },
      json=payload,
    )

  if r.status_code >= 400:
    raise HTTPException(status_code=502, detail=f"BTCPay error {r.status_code}: {r.text}")

  data = r.json()
  invoice_id = data.get("id")
  checkout = data.get("checkoutLink") or (f"{BTCPAY_URL}/i/{invoice_id}" if invoice_id else None)

  return {"invoiceId": invoice_id, "checkoutLink": checkout}

@app.post("/btcpay/webhook")
async def btcpay_webhook(request: Request):
  if not BTCPAY_WEBHOOK_SECRET:
    raise HTTPException(status_code=500, detail="Webhook secret not configured")

  sig = request.headers.get("btcpay-sig", "")
  raw = await request.body()

  if not _verify_btcpay_sig(raw, sig, BTCPAY_WEBHOOK_SECRET):
    raise HTTPException(status_code=401, detail="Invalid signature")

  event = json.loads(raw.decode("utf-8"))

  # Event payload: per sicurezza stampiamo solo ciò che serve
  invoice_id = event.get("invoiceId") or event.get("id")
  event_type = (event.get("type") or "").lower()

  conn = _db()
  try:
    conn.execute(
      "INSERT OR REPLACE INTO pending_invoices(invoice_id, credits, created_at) VALUES (?, ?, ?)",
      (invoice_id, body.credits, int(time.time())),
    )
    conn.commit()
  finally:
    conn.close()

  # Nella pratica conviene accreditare su eventi “paid/settled/complete”
  # Qui facciamo semplice: se è un evento di pagamento, accredita.
  is_paid_event = any(x in event_type for x in ["invoice_paid", "paid", "settled", "complete", "confirmed"])

  if not invoice_id:
    return {"ok": True}

  if not is_paid_event:
    return {"ok": True}

  credits_to_grant = 1000  # TODO: puoi leggerlo da metadata in futuro

  conn = _db()
  try:
    cur = conn.execute("SELECT 1 FROM invoice_claims WHERE invoice_id = ?", (invoice_id,))
    if cur.fetchone():
      return {"ok": True, "already_processed": True}

    # quanti crediti dare? prova a leggerli da pending_invoices
    cur = conn.execute("SELECT credits FROM pending_invoices WHERE invoice_id = ?", (invoice_id,))
    row = cur.fetchone()
    credits_to_grant = int(row[0]) if row else 1000

    token = _new_pro_token()
    token_hash = _hash_token(token)

    conn.execute(
      "INSERT INTO pro_tokens(token_hash, credits_left, created_at) VALUES (?, ?, ?)",
      (token_hash, credits_to_grant, int(time.time())),
    )
    conn.execute(
      "INSERT INTO invoice_claims(invoice_id, token_plain, token_hash, credits, claimed, created_at) VALUES (?, ?, ?, ?, 0, ?)",
      (invoice_id, token, token_hash, credits_to_grant, int(time.time())),
    )
    conn.commit()
  finally:
    conn.close()

  return {"ok": True}

@app.post("/pro/claim")
async def pro_claim(body: ClaimIn):
  conn = _db()
  try:
    cur = conn.execute(
      "SELECT token_plain, claimed, credits FROM invoice_claims WHERE invoice_id = ?",
      (body.invoiceId,),
    )
    row = cur.fetchone()
    if not row:
      raise HTTPException(status_code=404, detail="Invoice not found")

    token_plain, claimed, credits = row
    if int(claimed) == 1 or not token_plain:
      raise HTTPException(status_code=409, detail="Token already claimed")

    # “one-time”: dopo la prima lettura lo cancelliamo
    conn.execute(
      "UPDATE invoice_claims SET claimed=1, token_plain=NULL WHERE invoice_id = ?",
      (body.invoiceId,),
    )
    conn.commit()
    return {"token": token_plain, "credits": int(credits)}
  finally:
    conn.close()

  @app.get("/pro/status")
  async def pro_status(request: Request):
    token = (request.headers.get("x-void-pro-token") or "").strip()
    if not token:
      return {"status": "off", "credits_left": 0}

    th = _hash_token(token)

    conn = _db()
    try:
      cur = conn.execute("SELECT credits_left FROM pro_tokens WHERE token_hash = ?", (th,))
      row = cur.fetchone()

      if not row:
        raise HTTPException(status_code=401, detail="Invalid pro token")

      left = int(row[0])
      status = "active" if left > 0 else "exhausted"

      resp = JSONResponse(content={"status": status, "credits_left": max(left, 0)})
      resp.headers["X-Pro-Left"] = str(max(left, 0))
      return resp
    finally:
      conn.close()

@app.post("/chat")
async def chat(request: Request, body: ChatIn):
  headers = await _enforce_limits(request)

  payload = {
    "model": OLLAMA_MODEL,
    "messages": _build_msgs(body),
    "stream": False,
    "keep_alive": "5m",
  }

  async with httpx.AsyncClient(timeout=120) as client:
    r = await client.post(f"{OLLAMA_BASE_URL}/api/chat", json=payload)
    r.raise_for_status()
    data = r.json()

  resp = JSONResponse(content={"text": data["message"]["content"]})
  for k, v in headers.items():
    resp.headers[k] = v
  return resp

@app.post("/chat/stream")
async def chat_stream(request: Request, body: ChatIn):
  headers = await _enforce_limits(request)

  payload = {
    "model": OLLAMA_MODEL,
    "messages": _build_msgs(body),
    "stream": True,
    "keep_alive": "5m",
  }

  async def gen() -> AsyncGenerator[bytes, None]:
    async with httpx.AsyncClient(timeout=None) as client:
      async with client.stream("POST", f"{OLLAMA_BASE_URL}/api/chat", json=payload) as r:
        r.raise_for_status()
        async for line in r.aiter_lines():
          if await request.is_disconnected():
            break
          if not line:
            continue
          obj = json.loads(line)
          chunk = (obj.get("message") or {}).get("content") or ""
          if chunk:
            yield chunk.encode("utf-8")
          if obj.get("done") is True:
            break

  resp = StreamingResponse(gen(), media_type="text/plain; charset=utf-8")
  for k, v in headers.items():
    resp.headers[k] = v
  return resp

@app.post("/dev/reset-free")
async def dev_reset_free(request: Request, x_void_client_id: str = Header(default="")):
  if not DEV_RESET_ENABLED:
    raise HTTPException(status_code=404, detail="Not found")
  if redis is None:
    raise HTTPException(status_code=503, detail="Redis not configured")

  # resetta la STESSA chiave usata per i free credits (IP bucket)
  ipkey = _ip_bucket(request)
  free_key = f"free:{ipkey}"

  await redis.set(free_key, FREE_LIMIT, ex=FREE_TTL_SECONDS)
  return {"free_left": FREE_LIMIT}
